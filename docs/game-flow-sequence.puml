@startuml TAO Colosseum Game Flow with Drand Randomness

title TAO Colosseum - Game Flow Sequence Diagram
footer Generated for design review and community consensus

skinparam backgroundColor #FEFEFE
skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

actor "User/Resolver" as User
participant "TAO_Colosseum\nContract" as Colosseum
participant "Storage Precompile\n(0x807)" as Storage
database "Drand Pallet\nStorage" as DrandStorage
participant "Offchain Worker" as OCW
participant "Drand API\n(External)" as DrandAPI

== Background: Drand Pulse Ingestion (Continuous) ==

note over DrandAPI: Produces pulse every 3 seconds\n(round N, N+1, N+2, ...)

loop Every Bittensor block (~12 seconds)
    OCW -> DrandAPI: GET /public/latest
    DrandAPI --> OCW: Pulse(round, randomness, signature)
    OCW -> OCW: Verify BLS signature
    OCW -> DrandStorage: write_pulse(pulse)
    note right: Updates:\n- Pulses[round] = pulse\n- LastStoredRound = round
end

== Phase 1: Game Creation & Betting (100 blocks, ~20 min) ==

User -> Colosseum: startNewGame()
activate Colosseum
Colosseum -> Colosseum: Create game\nstartBlock = now\nendBlock = now + 100
Colosseum --> User: GameCreated(gameId, startBlock, endBlock)
deactivate Colosseum

note over Colosseum: BETTING PHASE\n(blocks 0-100)\n\nFinal Call Window:\nblocks 75-100

loop During betting period
    User -> Colosseum: placeBet(gameId, Side.Red/Blue)
    activate Colosseum
    Colosseum -> Colosseum: Record bet with placedAtBlock
    Colosseum --> User: BetPlaced(gameId, side, amount)
    deactivate Colosseum
end

== Phase 2: Resolution Phase 1 - Commit to Drand Round ==

note over User: block.number >= endBlock (100)

User -> Colosseum: resolveGame(gameId) [Phase 1]
activate Colosseum

Colosseum -> Storage: staticcall(DRAND_LAST_ROUND_KEY)
activate Storage
Storage -> DrandStorage: Read LastStoredRound
DrandStorage --> Storage: roundNumber (e.g., 12345)
Storage --> Colosseum: bytes(roundNumber)
deactivate Storage

Colosseum -> Colosseum: Decode u64 little-endian\nlastRound = 12345

alt lastRound == 0 (Drand completely unavailable)
    Colosseum -> Colosseum: _cancelGame("Drand not available")
    Colosseum --> User: GameCancelled(gameId)
else lastRound > 0
    Colosseum -> Colosseum: targetDrandRound = lastRound + 3\ncommitBlock = block.number\nphase = Calculating
    Colosseum --> User: DrandRoundCommitted(gameId, 12348, commitBlock)
end

deactivate Colosseum

note over Colosseum: TARGET: Round 12348\nCommitted at block N\nTimeout at block N + 7200

== Phase 3: Resolution Phase 2 - Finalize with Randomness ==

note over User: Wait for drand round 12348 to be available

User -> Colosseum: resolveGame(gameId) [Phase 2]
activate Colosseum

Colosseum -> Colosseum: Check timeout:\nblock.number > commitBlock + 7200?

alt TIMEOUT (> 7200 blocks / ~24 hours)
    Colosseum -> Colosseum: _cancelGame("Drand pulse timeout")
    Colosseum --> User: DrandTimeoutCancelled(gameId)\nGameCancelled(gameId)
else NOT TIMEOUT
    Colosseum -> Colosseum: Build storage key:\nprefix + blake2_128(round) + round
    
    Colosseum -> Storage: staticcall(pulseKey)
    activate Storage
    Storage -> DrandStorage: Read Pulses[12348]
    
    alt Pulse NOT yet available
        DrandStorage --> Storage: None
        Storage --> Colosseum: empty bytes []
        deactivate Storage
        Colosseum --> User: revert WaitingForRandomness()
        note right: User must retry later\n(typically 1-2 blocks)
    else Pulse available
        DrandStorage --> Storage: SCALE-encoded Pulse
        Storage --> Colosseum: bytes(pulse data)
        deactivate Storage
        
        Colosseum -> Colosseum: Decode SCALE:\n- skip round (8 bytes)\n- read compact length\n- extract 32-byte randomness
        
        alt Randomness == bytes32(0) [BUG: 2^-256 edge case]
            Colosseum --> User: revert WaitingForRandomness()
            note right #FF6666: FALSE NEGATIVE!\nPulse exists but\nrandomness happens to be 0
        else Randomness != bytes32(0)
            Colosseum -> Colosseum: actualEndBlock = \n(endBlock - 25) + (randomness % 25)
            
            Colosseum -> Colosseum: _calculateValidPools():\nMark bets after actualEndBlock as "late"
            
            Colosseum --> User: ActualEndBlockSet(gameId, actualEndBlock)
            
            alt Insufficient valid participation
                Colosseum -> Colosseum: _cancelGame("Insufficient participation")
                Colosseum --> User: GameCancelled(gameId)
            else Valid game
                Colosseum -> Colosseum: winner = minority pool\nphase = Resolved
                Colosseum --> User: GameResolved(gameId, winner)
            end
        end
    end
end

deactivate Colosseum

== Phase 4: Claims ==

User -> Colosseum: claimWinnings(gameId, side)
activate Colosseum

alt Late bet (isLateBet == true)
    Colosseum --> User: Full refund (LateBetRefunded)
else Winner
    Colosseum --> User: Payout from pool (WinningsClaimed)
else Loser
    Colosseum --> User: Nothing (bet lost)
end

deactivate Colosseum

@enduml
